/*
 * This is a Wiggleport module description file.
 * The format is JSON, but comments are allowed.
 *
 * Modules are wiggleport's unit of software pluggability, so typically one module
 * will correspond to one circuit board you can plug into other boards.
 *
 * In this case the module is the "Wiggle Spine" backplane, and we provide
 * up to seven attachment points for "wigglemod" modules.
 */

{
    // Modules support many of the same metadata keys you'll find in a packages.json file
    "name": "wiggle-spine",
    "version": "1.0.0",
    "description": "Wiggle Spine is a USB 2.0 backplane for up to 7 modules",
    "homepage": "http://wiggleport.org",
    "license": "MIT",

    /*
     * Besides the JSON description here, modules can include additional Verilog source files.
     * This is where the Verilog modules instantiated in the "logic" sections below come from.
     */
    "files": [ "wiggle-spine.v" ],

    "interface": "usb-ftdi",

    // Probe sequence: insert commands into a stream queue, option to load if results match

    /*
     * Module interface
     *
     * The module's interface describes what sort of slot it fits into, and when it can load.
     * If this module finds an attachment point with matching "class" and "detect" details,
     * the other objects here will be added to that attachment point.
     */
        "detect": { "vendorId": 7504, "productId": 24810 },

        /*
         * The USB bridge provides byte-wide FIFO streams, one in each direction.
         * Here we'll divide those byte streams into eight bit streams.
         */
        "streams": {

            "outputFIFOByteStream": {
                "width": 8,
                "rate": "outputClock",
                "pattern": [
                    [ "join",
                        "mod1.outputDataStream",    // Least significant bit
                        "mod2.outputDataStream",
                        "mod3.outputDataStream",
                        "mod4.outputDataStream",
                        "mod5.outputDataStream",
                        "mod6.outputDataStream",
                        "mod7.outputDataStream",
                        "outputControlStream" ]     // Most significant bit
                ]
            },

            "inputFIFOByteStream": {
                "width": 8,
                "rate": "inputClock",
                "pattern": [
                    [ "join",
                        "mod1.inputDataStream",     // Least significant bit
                        "mod2.inputDataStream",
                        "mod3.inputDataStream",
                        "mod4.inputDataStream",
                        "mod5.inputDataStream",
                        "mod6.inputDataStream",
                        "mod7.inputDataStream",
                        "inputControlStream" ]      // Most significant bit
                ]
            }
        }
    },

    /*
     * Spine clocks
     */

    "clocks": {

        // Note that the Wiggle Spine board has two crystals: the 12 MHz
        // crystal is only used for the USB interface. All other clocks
        // are derived by the Si5351 synthesizer from this 25 MHz crystal.

        "crystal": {
            "frequency": 25000000
        },

        // Template for either of the PLL units on the Si5351 chip

        "#pll-template": {
            // Synthesized frequency, between 600 and 900 MHz
            "frequency": [">=", 600000000, ["<=", 900000000,
                ["*", "crystal.frequency",
                    ["+", "multiplier.whole",
                        ["/", "multiplier.numerator", "multiplier.denominator"]
                    ]
                ]
            ]],

            // Fractional multiplier
            "multiplier": {
                "whole": [">=", 15, ["<=", 90, "#int"]],
                "numerator": [">=", 0, ["<", "denominator"], "#int"],
                "denominator": 1000000
                // ^ The data sheet claims, without further explanation,
                //   that the VCXO requires a denominator of 10^6.
                //   I suspect this is less of a hard requirement, and more
                //   to make their PPM calculations work out nicely.
            },

            // Register values, calculated from the multipliers
            "registers": {
                "p1": ["+", ["*", 128, "multiplier.whole"], "fp128", -512],
                "p2": ["-", ["*", 128, "multiplier.numerator"], ["*", "p3", "fp128"]],
                "p3": "multiplier.denominator",
                "fp128": ["//", ["*", 128, "multiplier.numerator"], "p3"]
            }
        },

        // Two PLLs: One is used as a fixed-frequency reference,
        // the other can track a sync input when that's present.

        "referencePLL": "#pll-template",
        "syncPLL": "#pll-template",





        "clk1": {
            ""
        }



        /*
         * The USB input and output FIFOs each run at a variable rate, which
         * libwigglespine determines based on the other sync'ed clocks and their
         * constraints.
         *
         * These clocks determine the advancement rate of the input and output
         * FIFO streams above, and the bandwidth available to the input and
         * output data streams on each module.
         */

        "inputClock": {

            "frequency": {
                "min": 2000000,
                "max": 28000000,
            },

            "syncWith": "externalClock"
        },
        "outputClock": {
            "min": 2000000,
            "max": 28000000,
            "syncWith": "externalClock"
        },

        /*
         * These audio clocks are available for modules to use, and the sample
         * This "sample clock" isn't used by the spine itself, but it's used by
         * many of our modules. This is a To make it easy for multiple The spine also provides a shared "audio clock", which allows all
         * modules that want it to share a single user-selectable clock.
         */
    },

    /*
     * Internal streams
     *
     * In the byte-wide USB data streams, 7 of those 8 bits go directly
     * to the submodules, but the eighth bit is used for various lower
     * bandwidth control features, including the per-module I2C ports.
     *
     * This control stream is framed using a simple bit stuffing
     * technique. The only place a group of three ones (111) may occur
     * is a the beginning of each 256-bit frame. To avoid these sequences
     * occurring elsewhere, several bit positions are always sent as zero.
     *
     * The control stream pattern must repeat at the same rate as our I2S
     * clock to be useful as a sync mechanism, so it must be 48 clock
     * cycles long or a mulitple thereof. (2 streams at 24-bit resolution)
     */

    "streams": {
        "outputControlStream": {
            "width": 1,
            "rate": "outputClock",
            "pattern": [
                // First 8 bits start with the sync pattern
                1, 1, 1,                                    // Sync pattern
                0,                                          // Padding
                [ "split", "i2c.outputBitStream", 1],       // I2C Data bit
                [ "split", "i2c.outputBitStream", 1],       // I2C Clock-transition bit
                0,                                          // Padding
                "dmx.bitStream"                             // Next item (1 bit) of DMX serial data

                // Every other 8 bit group in the frame begins with no sync pattern
                [ "repeat", 5,
                    0,                                      // Padding
                    0, 0,                                   // (Unallocated)
                    0,                                      // Padding
                    [ "split", "i2c.outputBitStream", 1],   // I2C Data bit
                    [ "split", "i2c.outputBitStream", 1],   // I2C Clock-transition bit
                    0,                                      // Padding
                    "dmx.bitStream"                         // Next item (1 bit) of DMX serial data
                ]
            ]
        },
        "inputControlStream": {
            "width": 1,
            "rate": "inputClock",
            "pattern": [
                // Match the same sync pattern as it comes back to us
                1, 1, 1,                                    // Sync pattern
                0,                                          // Padding
                [ "split", "i2c.inputBitStream", 1],        // I2C Data bit
                [ "split", "i2c.inputBitStream", 1],        // I2C Clock-transition bit
                0,                                          // Padding
                null,                                       // (Unallocated)
                [ "repeat", 31,
                    0,                                      // Padding
                    null, null,                             // (Unallocated)
                    0,                                      // Padding
                    [ "split", "i2c.inputBitStream", 1],    // I2C Data bit
                    [ "split", "i2c.inputBitStream", 1],    // I2C Clock-transition bit
                    0,                                      // Padding
                    null                                    // (Unallocated)
                ]
            ]
        }
    },

    /*
     * Named components
     *
     * Objects within are referenced using "component.member" notation.
     * Components may be used as attachment points for submodules.
     * If a "class" is specified, automatic attachment will be attempted.
     */

    "components": {

        /*
         * Internal I2C bus
         *
         * Modules are given a low-speed I2C port in order to do configuration
         * tasks without having to multiplex the main serial port. Each per-module
         * I2C port is multiplexed into a single shared I2C bus here.
         *
         * (Why I2C? Mostly because it's common for our submodules to pass this
         * on to a physical I2C port that's already present on some ADC or DAC.)
         *
         * In each direction, we have a 2 bit wide stream that encodes data in
         * the first (least significant) bit and clock in the second (most
         * significant) bit. The clock is encoded such that a "1" indicates the
         * clock staying high while data transitions (start/stop), and a "0"
         * indicates a clock pulse in which the data changes while clock is low.
         *
         *   Bus state | SCL       | SDA
         *   --------- | --------- | ---------
         *             |           |
         *   b00 = 0   | 0         | unchanged      <-- Data bit 0, also part of stop condition
         *             | 0         | 0
         *             | 1         | 0
         *             | 1         | 0
         *             |           |
         *   b01 = 1   | 0         | unchanged      <-- Data bit 1, also the ACK slot or
         *             | 0         | 1                              part of a repeated start condition
         *             | 1         | 1
         *             | 1         | 1
         *             |           |
         *   b10 = 2   | 1         | 0              <-- Part of the start condition
         *             |           |
         *   b11 = 3   | 1         | 1              <-- Idle
         *
         *           Start:  [3, 2, bits...]
         *            Stop:  [...bits, 1 (ack), 0, 3]
         *  Repeated start:  [...bits, 1 (ack), 1, 2, bits...]
         */

        "i2c": {
            "streams": {

                "outputBitStream": {
                    "width": 2,
                    "pattern": [
                        // Idle until a packet is ready
                        ["wait", "outputPacketStream", 3],

                        // Start condition
                        3, 2,

                        // This loop condition runs at least once, and repeats as long
                        // as there's any partial item buffered in the named stream.
                        ["repeat", ["until-aligned", "outputPacketStream"],

                            // Take 2 bits at a time from the output packet
                            ["split", "outputPacketStream", 2]
                        ],

                        // Stop condition
                        0, 3
                    ]
                },

                "outputPacketStream": {
                },

                "inputBitStream": {
                    "width": 2,
                    "pattern": [
                        // Let's think more about how patterns work with variable-width streams...
                        ["split", "inputI2CPacketStream", 2]
                    ]
                },
            },
            "logic": {

            }
        },

        /*
         * Onboard peripheral: Isolated DMX512 transmitter
         */

        "dmx": {
            "signals": {
                // Gate drive waveforms for isolated DC power
                "gate1": [ "fpga-io", 112 ],
                "gate2": [ "fpga-io", 107 ],
                // Outgoing serial data modulated with a carrier for the isolation circuit
                "tx1": [ "fpga-io", 118 ],
                "tx2": [ "fpga-io", 114 ]
            },
            "clocks": {
                "baudClock": {
                    "syncWith": "outputClock",
                    "rate": 250000
                },
                "modulationClock": {
                    "syncWith": "outputClock",
                    "rate": 12000000
                }
            },
            "streams": {
                // Entire DMX packets, as byte arrays.
                "packetStream": {
                    "width": 4096,      // 512 slots, 8 bits each
                    "buffer": 16384,    // Size in bits, 4 complete packets buffered
                },
                "bitStream": {
                    "width": 1,
                    "rate": "baudClock",
                    // Generate the outgoing DMX serial stream
                    "pattern": [
                        [ "wait", "packetStream", 1 ],  // As long as the packet stream is empty, output "1" (idle)
                        [ "repeat", 25, 0 ],            // Repeated "0" bits (break condition)
                        [ "repeat", 3, 1 ],             // Repeated "1" bits (mark after break)
                        0, [ "repeat", 8, 0 ], 1,1,     // Start code (0x00)
                        [ "split", "packetStream",      // Take one item from "dmxPackets", and split it up as follows
                            [ "repeat", 512,            // Same pattern for each of 512 DMX slots
                                0,                      // Start bit
                                [ "repeat", 8,          // Output 8 bits, one at a time (LSB first, same as buffered)
                                    [ "next", "packetStream", 1 ]
                                ],
                                1, 1                    // Two stop bits
                            ]
                        ]
                    ]
                }
            },
            "logic": [
                // Logic to drive the isolated power supply.
                // This doesn't take any inputs other than the 12 MHz clock.
                "dmx_gate_driver", {
                    "clk12": "modulationClock",
                    "out1": "gate1",
                    "out2": "gate2"
                },
                // The modulator takes asynchronous serial data generated by the dmxBits stream
                // pattern (in software) and in hardware it uses the 12 MHz clock to add modulation
                // so the data can cross our isolation transformer while retaining good pulse shape.
                "dmx_data_modulator", {
                    "clk12": "modulationClock",
                    "out1": "tx1",
                    "out2": "tx2",
                    "in": "dmxBits"
                }
            ]
        },

        /*
         * Driver for onboard status LED
         */

        "led": {
            "signals": {
                // Active-low PWM drive signals for the onboard RGB LED
                "red_n": [ "fpga-io", 93 ],
                "green_n": [ "fpga-io", 90 ],
                "blue_n": [ "fpga-io", 81 ],

                // Internal I2C port, for configuring the PWM driver
                "scl_in": "wire",
                "sda_in": "wire",
                "sda_out": "wire"
            },
            "logic": [
                "spine_led_controller", {
                    "red_out": "red_n",
                    "green_out": "green_n",
                    "blue_out": "blue_n",
                    "scl_in": "scl_in",
                    "sda_in": "sda_in",
                    "sda_out": "sda_out",
                }
            ]
        },

        /*
         * Attachment points for 7 modules.
         *
         * In addition to the objects defined in the class template for wigglemod,
         * we also define the specific I/O pins associated with each module.
         */

        "mod1": {
            "class": "wigglemod",
            "signals": {
                "pin1": [ "fpga-io", 87 ],
                "pin2": [ "fpga-io", 88 ],
                "pin3": [ "fpga-io", 80 ],
                "pin4": [ "fpga-io", 91 ],
                "pin5": [ "fpga-io", 76 ],
                "pin6": [ "fpga-io", 79 ],
                "pin7": [ "fpga-io", 73 ],
                "pin8": [ "fpga-io", 74 ]
            }
        },

        "mod2": {
            "class": "wigglemod",
            "signals": {
                "pin1": [ "fpga-io", 102 ],
                "pin2": [ "fpga-io", 104 ],
                "pin3": [ "fpga-io", 99 ],
                "pin4": [ "fpga-io", 98 ],
                "pin5": [ "fpga-io", 97 ],
                "pin6": [ "fpga-io", 96 ],
                "pin7": [ "fpga-io", 95 ],
                "pin8": [ "fpga-io", 101 ]
            }
        },

        "mod3": {
            "class": "wigglemod",
            "signals": {
                "pin1": [ "fpga-io", 113 ],
                "pin2": [ "fpga-io", 106 ],
                "pin3": [ "fpga-io", 115 ],
                "pin4": [ "fpga-io", 119 ],
                "pin5": [ "fpga-io", 116 ],
                "pin6": [ "fpga-io", 117 ],
                "pin7": [ "fpga-io", 121 ],
                "pin8": [ "fpga-io", 120 ]
            }
        },

        "mod4": {
            "class": "wigglemod",
            "signals": {
                "pin1": [ "fpga-io", 137 ],
                "pin2": [ "fpga-io", 138 ],
                "pin3": [ "fpga-io", 136 ],
                "pin4": [ "fpga-io", 135 ],
                "pin5": [ "fpga-io", 134 ],
                "pin6": [ "fpga-io", 129 ],
                "pin7": [ "fpga-io", 128 ],
                "pin8": [ "fpga-io", 122 ]
            }
        },

        "mod5": {
            "class": "wigglemod",
            "signals": {
                "pin1": [ "fpga-io", 8 ],
                "pin2": [ "fpga-io", 9 ],
                "pin3": [ "fpga-io", 4 ],
                "pin4": [ "fpga-io", 7 ],
                "pin5": [ "fpga-io", 144 ],
                "pin6": [ "fpga-io", 3 ],
                "pin7": [ "fpga-io", 1 ],
                "pin8": [ "fpga-io", 2 ]
            }
        },

        "mod6": {
            "class": "wigglemod",
            "signals": {
                "pin1": [ "fpga-io", 37 ],
                "pin2": [ "fpga-io", 38 ],
                "pin3": [ "fpga-io", 39 ],
                "pin4": [ "fpga-io", 33 ],
                "pin5": [ "fpga-io", 32 ],
                "pin6": [ "fpga-io", 31 ],
                "pin7": [ "fpga-io", 29 ],
                "pin8": [ "fpga-io", 28 ]
            }
        },

        "mod7": {
            "class": "wigglemod",
            "signals": {
                "pin1": [ "fpga-io", 143 ],
                "pin2": [ "fpga-io", 41 ],
                "pin3": [ "fpga-io", 43 ],
                "pin4": [ "fpga-io", 45 ],
                "pin5": [ "fpga-io", 44 ],
                "pin6": [ "fpga-io", 47 ],
                "pin7": [ "fpga-io", 48 ],
                "pin8": [ "fpga-io", 49 ]
            }
        }
    },

    /*
     * Class prototypes
     *
     * Components with a "class" member extend the prototypes here,
     * as if these objects were copied into each component.
     */

    "classes": {

        /*
         * Modules that plug into the Wiggle Spine, with 8 GPIOs and 3.3V, 5V, and 5-24V power.
         * Like PMOD, but with a wider connector to carry the extra power rails.
         */

        "wigglemod" : {
            "signals": {
                // Each submodule has an internal I2C port for low-speed communication
                "scl_in": "wire",
                "sda_in": "wire",
                "sda_out": "wire",

                // A shared counter runs parallel with all module serial ports, synchronized
                // using the control stream. Modules can use this counter to generate sync
                // signals for repeating patterns.
                "outputCounter": "wire[5:0]",
                "inputCounter": "wire[5:0]"
            },
            "streams": {
                // Each module gets a full-duplex serial port at the agreed-upon clock rates
                "outputDataStream": {
                    "width": 1,
                    "rate": "outputClock",
                    "pattern": [ 0 ]         // Default is all zeroes, overridden when a module loads
                },
                "inputDataStream": {
                    "width": 1,
                    "rate": "inputClock",
                    "pattern": [ null ]      // Default ignores all input, overridden when a module loads
                }
            }
        }
    }
}
